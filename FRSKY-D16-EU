/*
CC2500注意 : 
(1)SPI数据高位在前 , abxx xxxx  其中 : a : 为读写标志位(1 : 读   0 : 写)   b : 突发访问标志位     CS拉低后，必须等待SO引脚拉低，才能开始SPI通信。
*/
#include "include.h"

#define CC25_CSN_on   {GPIOF -> ODR |=  (1<<6);}
#define CC25_CSN_off  {GPIOF -> ODR &= ~(1<<6);}

#define FRSKYD16_CONFIG_CNTS  36
static const uint8_t cc2500_conf[FRSKYD16_CONFIG_CNTS][2]=
{
	{ CC2500_02_IOCFG0   , 0x06 },	// GDO0 指示同步码发送/接收情况 0x01?
	{ CC2500_00_IOCFG2   , 0x06 },	// GDO2 指示同步码发送/接收情况
	{ CC2500_17_MCSM1    , 0x0E },  // 0x0c
	{ CC2500_18_MCSM0    , 0x18 },  // OK
	{ CC2500_06_PKTLEN   , 0x23 },  // 0x1E
	{ CC2500_07_PKTCTRL1 , 0x04 },  // OK
	{ CC2500_08_PKTCTRL0 , 0x01 },  // 
	{ CC2500_3E_PATABLE  , 0xff },  // OK
	{ CC2500_0B_FSCTRL1  , 0x08 },  // 0x0A
	{ CC2500_0C_FSCTRL0  , 0x00 },	// OK? 0
	{ CC2500_0D_FREQ2    , 0x5c },	// OK         
	{ CC2500_0E_FREQ1    , 0x76 },  // 0x80
	{ CC2500_0F_FREQ0    , 0x00 },  // 0x27
	{ CC2500_10_MDMCFG4  , 0x7B },	//
	{ CC2500_11_MDMCFG3  , 0x61 },  // 0xF8   
	{ CC2500_12_MDMCFG2  , 0x03 },  // 0x13
	{ CC2500_13_MDMCFG1  , 0x23 },  // OK
	{ CC2500_14_MDMCFG0  , 0x7a },  // OK
	{ CC2500_15_DEVIATN  , 0x53 },  // 0x51
	{ CC2500_1B_AGCCTRL2 , 0x03 },	// OK	
	{ CC2500_19_FOCCFG   , 0x16 },  // OK
	{ CC2500_1A_BSCFG    , 0x6c },	// OK
	{ CC2500_1C_AGCCTRL1 , 0x40 },  // OK
	{ CC2500_1D_AGCCTRL0 , 0x91 },  // OK 
	{ CC2500_21_FREND1   , 0x56 },  // OK
	{ CC2500_22_FREND0   , 0x10 },  // OK
	{ CC2500_23_FSCAL3   , 0xa9 },  //OK
	{ CC2500_24_FSCAL2   , 0x0A },  //OK
	{ CC2500_25_FSCAL1   , 0x00 },  //OK
	{ CC2500_26_FSCAL0   , 0x11 },  //OK
	{ CC2500_29_FSTEST   , 0x59 },  // OK
	{ CC2500_2C_TEST2    , 0x88 },  // OK
	{ CC2500_2D_TEST1    , 0x31 },  // OK
	{ CC2500_2E_TEST0    , 0x0B },  // OK
	{ CC2500_03_FIFOTHR  , 0x07 },  //OK
	{ CC2500_09_ADDR     , 0x00 }  // OK

};

//==============================================================================
//			         延时程序
//==============================================================================
void DelayUs(uint16_t Us)
{
	for( ; Us ; Us--)
	{
		asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	}
}

void DelayMs(uint16_t Ms)
{
	for( ; Ms ; Ms--)
	{
		DelayUs(1000) ;
	}
}

//==============================================================================
//CS拉低后，必须等待SO拉低，再开始通信
//==============================================================================
static void CC2500_WaitingReady(void)
{
	uint16_t cnts = 0 ; 
	while ((GPIOG->IDR & (1<<7)) && (++cnts < 10000));
}

//==============================================================================
//			    写单个寄存器函数
//==============================================================================
void CC2500_WriteReg(uint8_t address, uint8_t data)
{
	CC25_CSN_off;  		DelayUs(2) ;
	CC2500_WaitingReady();	 
	SPI2_wr_Byte(address); 	DelayUs(2) ;
	SPI2_wr_Byte(data);     DelayUs(2) ;
	CC25_CSN_on;
} 

//==============================================================================
//			   写多个寄存器函数
//==============================================================================
static void CC2500_WriteRegisterMulti(uint8_t address, const uint8_t data[], uint8_t length)
{
	CC25_CSN_off;		DelayUs(2) ;
	CC2500_WaitingReady();
	SPI2_wr_Byte(CC2500_WRITE_BURST | address);
	for(uint8_t i = 0; i < length; i++) SPI2_wr_Byte(data[i]);DelayUs(2) ;
	CC25_CSN_on;
}


//==============================================================================
//			    读单个寄存器函数
//==============================================================================
uint8_t CC2500_ReadReg(uint8_t address)
{ 
	uint8_t result;
	CC25_CSN_off;		DelayUs(2) ;	
	CC2500_WaitingReady();
	SPI2_wr_Byte(CC2500_READ_SINGLE | address);
	result = SPI2_rd_Byte(); 
	CC25_CSN_on;
	return(result); 
} 

//==============================================================================
//			     CC2500命令
//==============================================================================
void CC2500_Strobe(uint8_t state)
{
	CC25_CSN_off;		
	CC2500_WaitingReady();	DelayUs(2) ;
	SPI2_wr_Byte(state); 	DelayUs(2) ;
	CC25_CSN_on;
}

//==============================================================================
//			   写缓存数据
//==============================================================================
void CC2500_WriteData(uint8_t *dpbuffer, uint8_t len)
{
	CC2500_Strobe(CC2500_SFTX);
	CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, dpbuffer, len);
	CC2500_Strobe(CC2500_STX);
}

//==============================================================================
//		             设置CC2500功率
//==============================================================================
void CC2500_SetPower(uint8_t power)
{
  	static uint8_t prev_power = CC2500_POWER_1 ; 
	if(prev_power != power)
	{	
	  	prev_power = power ; 
		CC2500_WriteReg(CC2500_3E_PATABLE, power);
	}
}

//==============================================================================
//			       CC2500初始化
//==============================================================================
bool  CC2500_Init()
{
  	bool CC2500RestError_flg = false ; 
	SPI2_Init();
	
	//CS_CC2500(PF6)	
	GPIOF -> CR1 |= (1<<6) ; 
	GPIOF -> CR2 |= (1<<6) ; 
	GPIOF -> DDR |= (1<<6) ; 
	CC25_CSN_on;
	
	
	GPIOF -> CR1 |= (1<<5) ; 
	GPIOF -> CR2 |= (1<<5) ; 
	GPIOF -> DDR |= (1<<5) ; 
	
	DelayMs(15);

	//复位 CC2500 
	CC2500_Strobe(CC2500_SRES);
	DelayMs(15);
	
	//读取寄存器值和初始化值比对，判断芯片是否初始化成功
	if(CC2500_ReadReg(CC2500_0E_FREQ1) != 0xC4)  CC2500RestError_flg = true ;
	DelayMs(1);
	DelayMs(10);
	//如果复位成功 , 初始化CC2500 ; 如果失败，不用初始化，置位复位失败标志位。
	if(!CC2500RestError_flg)
	{
		for (uint8_t i = 0 ; i < FRSKYD16_CONFIG_CNTS ; ++i) 
		{
			CC2500_WriteReg(cc2500_conf[i][0], cc2500_conf[i][1]);		        //初始化 CC2500 寄存器
			DelayUs(20);
		}
		CC2500_Strobe(CC2500_SIDLE);					//进入闲置状态
		DelayUs(20);
		CC2500_SetPower(CC2500_POWER_15);				//初始化 小功率发射 (正常发射后，在设置成最大功率)	
		CC2500_Strobe(CC2500_SIDLE);					//进入闲置状态
		DelayUs(20);
		
		//设置寄存器完成后，SPI读取速度切换到6Mhz
		SPI2 -> CR1 &= ~(1<<6) ; 
		SPI2 -> CR1 &= ~((1<<5)|(1<<4)|(1<<3)) ; 
		DelayMs (10);
		SPI2 -> CR1 |= (1<<6) ; 
		
	}
	return CC2500RestError_flg ; 
}
